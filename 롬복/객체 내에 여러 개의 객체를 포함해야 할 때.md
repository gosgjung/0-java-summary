# 객체 내에 여러 개의 객체를 포함해야 할 때



환불 요구사항

- 주문에 대한 환불을 받는다.
- 환불에 대한 수단은 결제를 수단으로 한다.
  - e.g. 무통장 입금, 카드 결제
  - 카드 결제시 결제 카드 정보를 입력받아 환불한다.
  - 무통장 입금은 환불 받은 계좌 정보를 넘겨 받아 금액을 환불한다.
- 무통장 입금, 카드 결제 등 반드시 수단은 1개여야 한다.



# 환불 객체 1) 모호한 생성자와 builder

## 무통장 입금, 카드결제 객체 둘 중 하나만 받아야 하는데, 둘다 받을 수 있게 코드가 열린 경우

<br>



## Refund1 클래스 >> 무통장, 카드 둘을 모두 받는 모호한 생성자와 Builder

Refund1 클래스를 예로 들어보자.

Refund1 클래스는 아래와 같이 되어있다.

그리고 Refund1 클래스에 필요한 Address, CreditCard, Order 클래스에 대한 정의는 최 하단부에 정리해두었다.

```java
package io.study.jpa.builder_must_limit.entity;

import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;

import javax.persistence.*;

@Entity
@Table(name = "refund1")
@Getter
@NoArgsConstructor
public class Refund1 {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Embedded
    private Account2 account;

    @Embedded
    private CreditCard creditCard;

    @OneToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Builder
    public Refund1(Account2 account, CreditCard creditCard, Order order){
        // 1. account :: null,      creditCard -> not null
        // 2. account :: not null,  creditCard -> null
        // 3. account :: null,      creditCard -> null
        // 4. account :: not null,  creditCard :: not null

        // 제약조건 체크가 까다로워졌다. Refund1Test.java 를 보자.

    }
}
```

<br>

Refund1 이라는 환불 객체에 대한 테스트 코드를 작성해보자.

Refund1Test 클래스를 보자.

```java
package io.study.jpa.builder_must_limit.entity;

import org.junit.jupiter.api.Test;

public class Refund1Test {

    @Test
    public void 환불객체_Refund1_의_복잡함을_보기위한_코드(){
        //
        Refund1.builder()
                .account(null)
                .creditCard(null)
                .order(Order.builder()
                        .address(
                            Address.builder()
                                .address1("address1")
                                .address2("address2")
                                .zip("zip")
                                .build()
                        )
                        .build()
                )
                .build();

        // 위 코드의 단점
        // 1) Account 를 넘겨야할지 CreditCard 를 넘겨야할지 분간이 안가게 될 수 있다.
        // 2) 코드가 명확하게 디자인 되어있지 않다.
        //  Account, CreditCard 둘 중 하나만 받아야 하는것이 목표인데도 불구하고
        //  코드 상으로는 아직까지 현재로는 Account, CreditCard 모두 받을 수 있는 구조다.
    }
}
```

<br>

이렇게 Refund1 이라는 환불 객체에 무통장입금으로 환불할지, 신용카드로 환불할지에 대해 모호하게 모두 객체를 받다보니, 두가지 문제점이 생겼다.

- 1. Account를 넘길지, CreditCard를 넘길지 Refund1 객체를 생성하는 코드 측에서는 혼란스러워진다.

- 1. 코드가 명확하게 디자인되지 않았다.

  - Account, CreditCard 둘 중 하나만 받아야 하는 것이 목표인데도 코드 상으로는 아직까지는 Account, CreditCard 둘 모두를 받을 수 있는 구조다.

<br>



# 환불 객체 2) 용도에 따라 생성자, Builder 를 따로 정의

## Refund2 클래스 >> 목적에 따라 무통장, 카드 둘 중 하나만 받도록 목적에 따라 생성자,Builder를 따로 정의

effective java 에서는 생성자의 매개변수가 많으면, 생성자 대신에 정적 팩터리 메서드를 사용해라 라고 이야기하고 있다.

생성자에는 메서드 이름을 부여할 수 없다. 따라서 객체 생성의 의도가 명확히 드러나지 않기 때문에, 가급적이면 정적 팩터리 메서드를 이용하라고 권고하고 있다.

Builder를 이름을다르게 구현한것 역시 정적 팩터리 메서드를 따로 두려고 하는 것과 목적이 유사하다.

새로 구현한 Refund2 클래스는 아래와 같다.

Builder 클래스, 메서드, 생성자를 무통장입금을 통한 환불일때와 신용카드를 통한 환불일 경우로 나뉘어 사용하게끔 구현했다.

```java
package io.study.jpa.builder_must_limit.entity;

import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.util.Assert;

import javax.persistence.*;

@Entity
@Table(name = "refund2")
@Getter
@NoArgsConstructor
public class Refund2 {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Embedded
    private Account2 account;

    @Embedded
    private CreditCard creditCard;

    @OneToOne
    @JoinColumn(name = "order_id", nullable = false)
    private Order order;

    @Builder(builderClassName = "ByAccountBuilder", builderMethodName = "ByAccountBuilder")
    public Refund2(Account2 account, Order order){
        Assert.notNull(account, "account must not be null");
        Assert.notNull(order, "order must not be null");

        this.account = account;
        this.order = order;
    }

    @Builder(builderClassName = "ByCreditCardBuilder", builderMethodName = "ByCreditCardBuilder")
    public Refund2(CreditCard creditCard, Order order){
        Assert.notNull(creditCard, "creditCard must not be null");
        Assert.notNull(order, "order must not be null");

        this.creditCard = creditCard;
        this.order = order;
    }
}
```

<br>

이제 이것을 테스트하는 코드를 작성해보면 아래와 같다.

```java
package io.study.jpa.builder_must_limit.entity;

import org.assertj.core.api.Assertions;
import org.assertj.core.api.BDDAssertions;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;

public class Refund2Test {

    Account2 account;

    CreditCard creditCard;

    Address address;

    Order order;

    @BeforeEach
    public void INIT(){
        account = Account2.builder()
                .accountNumber("111")
                .accountHolder("카림벤제마")
                .bankName("JP MORGAN")
                .build();

        creditCard = CreditCard.builder()
                .creditHolder("카림벤제마")
                .creditNumber("111")
                .build();

        address = Address.builder()
                .address1("address1")
                .address2("address2")
                .zip("zip")
                .build();

        order = Order.builder()
                .address(address)
                .build();
    }

    @Test
    public void 무통장입금에_대한_환불(){
        Refund2 refund = Refund2.ByAccountBuilder()
                .account(account)
                .order(order)
                .build();

        BDDAssertions.then(refund.getAccount()).isEqualTo(account);
        BDDAssertions.then(refund.getOrder()).isEqualTo(order);
    }

    @Test
    public void 무통장환불계좌가_null_일_경우(){
        Assertions.assertThatThrownBy(()->{
            Refund2 refund = Refund2.ByAccountBuilder()
                    .account(null)
                    .order(order)
                    .build();

//            BDDAssertions.then(refund.getAccount()).isEqualTo(null);
//            BDDAssertions.then(refund.getOrder()).isEqualTo(order);
        }).isInstanceOf(IllegalArgumentException.class);

    }

    @Test
    public void 신용카드에_대한_환불(){
        Refund2 refund = Refund2.ByCreditCardBuilder()
                .creditCard(creditCard)
                .order(order)
                .build();

        BDDAssertions.then(refund.getCreditCard()).isEqualTo(creditCard);
        BDDAssertions.then(refund.getOrder()).isEqualTo(order);
    }

    @Test
    public void 환불하려는_신용카드_정보가_null인_경우(){
        Assertions.assertThatThrownBy(()->{
            Refund2.ByCreditCardBuilder()
                    .creditCard(creditCard)
                    .order(order)
                    .build();
        }).isInstanceOf(IllegalArgumentException.class);
    }
}
```

<br>

# Address, Order, CreditCard, Account2

## Address

```java
package io.study.jpa.builder_must_limit.entity;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.util.Assert;

import javax.persistence.Column;
import javax.persistence.Embeddable;

@Embeddable
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Address {

    @Column(name = "address1", nullable = false)
    private String address1;

    @Column(name = "address2", nullable = false)
    private String address2;

    @Column(name = "zip", nullable = false)
    private String zip;

    @Builder
    public Address(final String address1,
                   final String address2,
                   final String zip){
        Assert.hasText(address1, "address1 must not be empty");
        Assert.hasText(address2, "address2 must not be empty");
        Assert.hasText(zip, "zip must not be empty");

        this.address1 = address1;
        this.address2 = address2;
        this.zip = zip;
    }
}
```

<br>

## Order

```java
package io.study.jpa.builder_must_limit.entity;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.util.Assert;

import javax.persistence.*;

@Entity
@Table(name = "orders")
@NoArgsConstructor(access = AccessLevel.PROTECTED)
@Getter
public class Order {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Embedded
    private Address address;

    @Builder
    public Order(Address address){
        Assert.notNull(address, "address must not be null");

        this.address = address;
    }
}
```

<br>

## CreditCard

```java
package io.study.jpa.builder_must_limit.entity;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.util.Assert;

import javax.persistence.Column;
import javax.persistence.Embeddable;

@Embeddable
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class CreditCard {

    @Column(name = "credit_number", nullable = false)
    private String creditNumber;

    @Column(name = "credit_holder", nullable = false)
    private String creditHolder;

    @Builder
    public CreditCard(final String creditNumber,
                      final String creditHolder){
        Assert.hasText(creditNumber, "creditNumber must not be empty");
        Assert.hasText(creditHolder, "creditHolder must not be empty");

        this.creditNumber = creditNumber;
        this.creditHolder = creditHolder;
    }

}
```

<br>

## Account2

```java
package io.study.jpa.builder_must_limit.entity;

import lombok.AccessLevel;
import lombok.Builder;
import lombok.Getter;
import lombok.NoArgsConstructor;
import org.springframework.util.Assert;

import javax.persistence.Column;
import javax.persistence.Embeddable;

@Embeddable
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class Account2 {

    @Column(name = "bank_name", nullable = false)
    private String bankName;

    @Column(name = "account_number", nullable = false)
    private String accountNumber;

    @Column(name = "account_holder", nullable = false)
    private String accountHolder;

    @Builder
    public Account2(final String bankName,
                    final String accountNumber,
                    final String accountHolder){

        Assert.hasText(bankName, "bankName must not be empty");
        Assert.hasText(accountNumber, "accountNumber must not be empty");
        Assert.hasText(accountHolder, "accountHolder must not be empty");

        this.bankName = bankName;
        this.accountNumber = accountNumber;
        this.accountHolder = accountHolder;

    }
}
```